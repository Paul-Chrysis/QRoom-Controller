<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive Heatmap Maker</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: Arial, sans-serif;
    }
    #controls {
      margin-bottom: 20px;
      padding: 15px;
      background: #f5f5f5;
      border-radius: 5px;
    }
    #container {
      position: relative;
      width: 1000px;
      height: 600px;
      border: 2px dashed #ccc;
      margin: 0 auto;
    }
    #imagePreview {
      width: 100%;
      height: 100%;
      object-fit: contain;
      position: absolute;
      top: 0;
      left: 0;
    }
    #heatmapCanvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: auto;
    }
    .color-btn {
      width: 30px;
      height: 30px;
      border: 2px solid #fff;
      border-radius: 50%;
      margin: 0 5px;
      cursor: pointer;
    }
    .color-btn.active {
      border-color: #000;
    }
    #message {
      text-align: center;
      color: #666;
      margin: 10px 0;
    }
    .btn {
      padding: 8px 15px;
      margin: 0 5px;
      border: none;
      border-radius: 4px;
      background: #007bff;
      color: white;
      cursor: pointer;
    }
    .btn:hover {
      background: #0056b3;
    }
    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <div id="controls">
    <input type="file" id="imageInput" accept="image/*">
    <button id="clearBtn" class="btn" disabled>Clear All</button>
    <button id="exportBtn" class="btn" disabled>Export Image</button>
    <div style="margin: 15px 0;">
      <label>Select Control Point Color:</label>
      <button class="color-btn active" style="background: #FF0000" data-color="#FF0000"></button>
      <button class="color-btn" style="background: #00FF00" data-color="#00FF00"></button>
      <button class="color-btn" style="background: #0000FF" data-color="#0000FF"></button>
      <button class="color-btn" style="background: #FF00FF" data-color="#FF00FF"></button>
      <button class="color-btn" style="background: #FFD700" data-color="#FFD700"></button>
    </div>
  </div>

  <div id="container">
    <img id="imagePreview" style="display: none;">
    <canvas id="heatmapCanvas"></canvas>
  </div>
  
  <div id="message">Upload an image to begin</div>

  <script>
    const canvas = document.getElementById('heatmapCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('container');
    const imagePreview = document.getElementById('imagePreview');
    const imageInput = document.getElementById('imageInput');
    const clearBtn = document.getElementById('clearBtn');
    const exportBtn = document.getElementById('exportBtn');
    const message = document.getElementById('message');

    // Array to store click positions with color information
    let clicks = [];
    let currentColor = '#FF0000'; // Default color
    
    // Object to track counters for each color
    let colorCounters = {
      '#FF0000': 0,
      '#00FF00': 0,
      '#0000FF': 0,
      '#FF00FF': 0,
      '#FFD700': 0
    };

    // Handle color selection
    document.querySelectorAll('.color-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        document.querySelector('.color-btn.active').classList.remove('active');
        btn.classList.add('active');
        currentColor = btn.dataset.color;
      });
    });

    // Handle image upload
    imageInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          imagePreview.src = e.target.result;
          imagePreview.style.display = 'block';
          message.textContent = 'Click on the image to add heat points';
          clearBtn.disabled = false;
          exportBtn.disabled = false;
          // Clear existing heat points when new image is uploaded
          clicks = [];
          // Reset color counters
          Object.keys(colorCounters).forEach(color => {
            colorCounters[color] = 0;
          });
          resizeCanvas();
        };
        reader.readAsDataURL(file);
      }
    });

    // Set canvas dimensions to match the container
    function resizeCanvas() {
      const rect = container.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      redrawHeatmap();
    }

    // Get the actual dimensions and position of the displayed image
    function getImageDisplayInfo() {
      const containerRect = container.getBoundingClientRect();
      const containerWidth = containerRect.width;
      const containerHeight = containerRect.height;
      
      const imgWidth = imagePreview.naturalWidth;
      const imgHeight = imagePreview.naturalHeight;
      
      // Calculate the displayed dimensions (maintaining aspect ratio)
      let displayWidth, displayHeight;
      const imgRatio = imgWidth / imgHeight;
      const containerRatio = containerWidth / containerHeight;
      
      if (imgRatio > containerRatio) {
        // Image is wider than container (relative to height)
        displayWidth = containerWidth;
        displayHeight = containerWidth / imgRatio;
      } else {
        // Image is taller than container (relative to width)
        displayHeight = containerHeight;
        displayWidth = containerHeight * imgRatio;
      }
      
      // Calculate the position (centered in container)
      const left = (containerWidth - displayWidth) / 2;
      const top = (containerHeight - displayHeight) / 2;
      
      return {
        displayWidth,
        displayHeight,
        left,
        top,
        containerWidth,
        containerHeight,
        imgWidth,
        imgHeight
      };
    }

    // Draw the heatmap
    function redrawHeatmap() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      if (!imagePreview.src) return;
      
      // Group clicks by color
      const clicksByColor = {};
      clicks.forEach(point => {
        if (!clicksByColor[point.color]) {
          clicksByColor[point.color] = [];
        }
        clicksByColor[point.color].push(point);
      });

      // Draw each color group separately
      Object.entries(clicksByColor).forEach(([color, points]) => {
        ctx.globalCompositeOperation = 'lighter';
        
        points.forEach(point => {
          const radius = 15; // Reduced radius for more precise heatmarks
          const gradient = ctx.createRadialGradient(point.x, point.y, 0, point.x, point.y, radius);
          const rgba = hexToRgba(color);
          gradient.addColorStop(0, `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, 0.8)`); // Increased opacity for more vibrant colors
          gradient.addColorStop(1, `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, 0)`);
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
          ctx.fill();
          
          // Draw the point number
          ctx.globalCompositeOperation = 'source-over';
          ctx.font = 'bold 14px Arial';
          ctx.fillStyle = color; // Use the heatmark color for the number
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 2;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.strokeText(point.number.toString(), point.x, point.y);
          ctx.fillText(point.number.toString(), point.x, point.y);
          ctx.globalCompositeOperation = 'lighter';
        });
      });

      ctx.globalCompositeOperation = 'source-over';
    }

    // Convert hex color to rgba
    function hexToRgba(hex) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return { r, g, b };
    }

    // Capture click events
    canvas.addEventListener('click', (e) => {
      if (!imagePreview.src) return;
      
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      // Get image display info
      const imageInfo = getImageDisplayInfo();
      
      // Check if click is within the image bounds
      if (x < imageInfo.left || x > imageInfo.left + imageInfo.displayWidth ||
          y < imageInfo.top || y > imageInfo.top + imageInfo.displayHeight) {
        return; // Click is outside the image area
      }
      
      // Increment counter for the current color
      colorCounters[currentColor]++;
      
      // Add click with color and number
      clicks.push({ 
        x, 
        y, 
        color: currentColor,
        number: colorCounters[currentColor]
      });
      
      redrawHeatmap();
    });

    // Clear all heat points
    clearBtn.addEventListener('click', () => {
      clicks = [];
      // Reset color counters
      Object.keys(colorCounters).forEach(color => {
        colorCounters[color] = 0;
      });
      redrawHeatmap();
    });

    // Export combined image
    exportBtn.addEventListener('click', () => {
      if (!imagePreview.src) return;
      
      // Get image display info
      const imageInfo = getImageDisplayInfo();
      
      // Create a new canvas for the final image using the actual image dimensions
      const exportCanvas = document.createElement('canvas');
      exportCanvas.width = imagePreview.naturalWidth;
      exportCanvas.height = imagePreview.naturalHeight;
      const exportCtx = exportCanvas.getContext('2d');

      // Draw the background image at its natural dimensions
      exportCtx.drawImage(imagePreview, 0, 0, imagePreview.naturalWidth, imagePreview.naturalHeight);
      
      // Draw each heatmark adjusted to the image's actual dimensions
      exportCtx.globalCompositeOperation = 'lighter';
      
      // Group clicks by color
      const clicksByColor = {};
      clicks.forEach(point => {
        if (!clicksByColor[point.color]) {
          clicksByColor[point.color] = [];
        }
        clicksByColor[point.color].push(point);
      });
      
      // Draw each color group separately on the export canvas
      Object.entries(clicksByColor).forEach(([color, points]) => {
        points.forEach(point => {
          // Calculate the relative position within the displayed image
          const relativeX = (point.x - imageInfo.left) / imageInfo.displayWidth;
          const relativeY = (point.y - imageInfo.top) / imageInfo.displayHeight;
          
          // Convert to position in the original image dimensions
          const originalX = relativeX * imagePreview.naturalWidth;
          const originalY = relativeY * imagePreview.naturalHeight;
          
          // Calculate radius proportional to image size
          const radius = 15// * (imagePreview.naturalWidth / imageInfo.displayWidth);
          
          const gradient = exportCtx.createRadialGradient(originalX, originalY, 0, originalX, originalY, radius);
          const rgba = hexToRgba(color);
          gradient.addColorStop(0, `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, 0.8)`); // Increased opacity to match display
          gradient.addColorStop(1, `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, 0)`);
          
          exportCtx.fillStyle = gradient;
          exportCtx.beginPath();
          exportCtx.arc(originalX, originalY, radius, 0, Math.PI * 2);
          exportCtx.fill();
          
          // Draw the point number
          exportCtx.globalCompositeOperation = 'source-over';
          const fontSize = Math.max(14 * (imagePreview.naturalWidth / imageInfo.displayWidth), 14);
          exportCtx.font = `bold ${fontSize}px Arial`;
          exportCtx.fillStyle = color; // Use the heatmark color for the number
          exportCtx.strokeStyle = 'black';
          exportCtx.lineWidth = 2;
          exportCtx.textAlign = 'center';
          exportCtx.textBaseline = 'middle';
          exportCtx.strokeText(point.number.toString(), originalX, originalY);
          exportCtx.fillText(point.number.toString(), originalX, originalY);
          exportCtx.globalCompositeOperation = 'lighter';
        });
      });
      
      exportCtx.globalCompositeOperation = 'source-over';

      // Create download link
      const link = document.createElement('a');
      link.download = 'heatmap.png';
      link.href = exportCanvas.toDataURL('image/png');
      link.click();
    });

    // Handle window resize
    window.addEventListener('resize', resizeCanvas);
    
    // Initial canvas setup
    resizeCanvas();
  </script>
</body>
</html>
